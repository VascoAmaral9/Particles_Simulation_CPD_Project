[33mcommit fa29c51856eab06ed29e014b01c0da34a680fd8d[m
Author: jvelez96 <j.velez2210@gmail.com>
Date:   Thu Mar 28 12:55:18 2019 -0700

    finished (but still needs to be further tested) the calculate center of mass function

[1mdiff --git a/grid.cpp b/grid.cpp[m
[1mindex 77f72a1..0a89db1 100644[m
[1m--- a/grid.cpp[m
[1m+++ b/grid.cpp[m
[36m@@ -1,5 +1,5 @@[m
 //grid.c[m
[31m-#include "grid.h"[m
[32m+[m[32m#include "particle.h"[m
 [m
 Grid::Grid() {[m
    std::cout << "Grid created" << std::endl;[m
[36m@@ -12,6 +12,9 @@[m [mvoid Grid::setX (double x_new) {[m
 double Grid::getX () {[m
     return x;[m
 }[m
[32m+[m[32mvoid Grid::add_toX(double x_new){[m
[32m+[m[32m  x += x_new;[m
[32m+[m[32m}[m
 [m
 void Grid::setY (double y_new) {[m
     y = y_new;[m
[36m@@ -21,19 +24,55 @@[m [mdouble Grid::getY () {[m
     return y;[m
 }[m
 [m
[31m-void Grid::insert_list(int new_par){[m
[31m-  par_list.push_front(new_par);[m
[32m+[m[32mvoid Grid::add_toY (double y_new) {[m
[32m+[m[32m    y += y_new;[m
 }[m
 [m
 [m
[32m+[m[32mvoid Grid::insert_list(int new_par){[m
[32m+[m[32m  par_list.push_front(new_par);[m
[32m+[m[32m}[m
 [m
[31m-//Aqui vai-se calcular o centro de massa (x, y) de uma celula com a expressao 1/M* E(mi * (x,y))[m
[32m+[m[32m//fazer funÃ§ao para limpar a lista[m
 [m
[32m+[m[32mvoid Grid::setM(double m_new){[m
[32m+[m[32m  M = m_new;[m
[32m+[m[32m}[m
 [m
[31m-void Grid::setM (double m_new) {[m
[31m-    M = m_new;[m
[32m+[m[32mvoid Grid::add_toM(double m_new){[m
[32m+[m[32m  M += m_new;[m
 }[m
 [m
[32m+[m[32m//Aqui vai-se calcular o centro de massa (x, y) de uma celula com a expressao 1/M* E(mi * (x,y))[m
[32m+[m
 double Grid::getM () {[m
     return M;[m
 }[m
[32m+[m
[32m+[m[32m/* FunÃ§Ã£o para fazer o update geral de todos os centros de massa com base nas particulas que tem no momento */[m
[32m+[m[32mvoid update_center (int size,Grid **grid, Particle *par){[m
[32m+[m
[32m+[m[32m  long long i, j;[m
[32m+[m[32m  double new_x, new_y;[m
[32m+[m[32m  for(i=0;i<size;i++){[m
[32m+[m[32m    for(j=0;j<size;j++){[m
[32m+[m[32m      grid[i][j].setX(0);[m
[32m+[m[32m      grid[i][j].setY(0);[m
[32m+[m[32m      std::list <int> :: iterator it;[m
[32m+[m[32m      for(it = grid[i][j].par_list.begin(); it != grid[i][j].par_list.end(); ++it){[m
[32m+[m[32m        new_x = (par[*it].getX() * par[*it].getM())/grid[i][j].getM();[m
[32m+[m[32m        grid[i][j].add_toX(new_x);[m
[32m+[m[32m        new_y = (par[*it].getY() * par[*it].getM())/grid[i][j].getM();[m
[32m+[m[32m        grid[i][j].add_toY(new_y);[m
[32m+[m[32m      }[m
[32m+[m[32m      std::cout << "Center of Mass\nX:" << grid[i][j].getX() << std::endl;[m
[32m+[m[32m      std::cout << "Y: " << grid[i][j].getY() << std::endl;[m
[32m+[m[32m      //Percorrer a lista desta celula e[m
[32m+[m[32m      /*[m
[32m+[m[32m      std::cout << "X: " << grid[i][j].getX() << std::endl;[m
[32m+[m[32m      std::cout << "Y: " << grid[i][j].getY() << std::endl;[m
[32m+[m[32m      */[m
[32m+[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[1mdiff --git a/grid.h b/grid.h[m
[1mindex 99239e9..b5b6251 100644[m
[1m--- a/grid.h[m
[1m+++ b/grid.h[m
[36m@@ -16,12 +16,15 @@[m [mclass Grid {[m
     Grid();[m
     void setX(double x_new);[m
     double getX();[m
[32m+[m[32m    void add_toX(double y_new);[m
     void setY(double x_new);[m
     double getY();[m
[31m-    void setM(double x_new);[m
[32m+[m[32m    void add_toY(double y_new);[m
[32m+[m[32m    void setM(double M_new);[m
     double getM();[m
     void insert_list(int new_par);[m
     std::list<int> par_list;[m
[32m+[m[32m    void add_toM(double m_new);[m
 [m
   private:[m
     double x;[m
[1mdiff --git a/init_particles.cpp b/init_particles.cpp[m
[1mindex b0c91a2..2447e33 100644[m
[1m--- a/init_particles.cpp[m
[1m+++ b/init_particles.cpp[m
[36m@@ -11,19 +11,6 @@[m [mvoid showlist(std::list <int> g)[m
     std::cout << '\n';[m
 }[m
 [m
[31m-void init_grid(int size, Grid **grid){[m
[31m-  long long i, j;[m
[31m-  for(i=0; i< size;i++){[m
[31m-    for(j=0;j<size;j++){[m
[31m-      grid[i][j].setX(i);[m
[31m-      grid[i][j].setY(j);[m
[31m-      std::cout << "X: " << grid[i][j].getX() << std::endl;[m
[31m-      std::cout << "Y: " << grid[i][j].getY() << std::endl;[m
[31m-[m
[31m-    }[m
[31m-  }[m
[31m-}[m
[31m-[m
 //no init particles, arredondar o x e o y, e mete-lo logo na lista da celula certa e ir dando um +=  a uma variavel para termos[m
 //a soma de todas as massas no inicio sem complexidade extra de percorrer todas as listas de novo[m
 [m
[36m@@ -48,8 +35,24 @@[m [mvoid init_particles(long seed, long ncside, long long n_part, Particle *par, Gri[m
     x = floor(par[i].getX() * ncside);[m
     y = floor(par[i].getY() * ncside);[m
     grid[x][y].insert_list(i);[m
[32m+[m[32m    grid[x][y].add_toM(par[i].getM());[m
     showlist(grid[x][y].par_list);[m
[31m-    printf("x:%lld y:%lld\n",x,y);[m
[32m+[m[32m    printf("x:%lld y:%lld\ntotal M:%f\n",x,y, grid[x][y].getM());[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m//desnecessaria[m
[32m+[m[32mvoid init_grid(int size, Grid **grid){[m
[32m+[m[32m  long long i, j;[m
[32m+[m[32m  for(i=0; i< size;i++){[m
[32m+[m[32m    for(j=0;j<size;j++){[m
[32m+[m[32m      grid[i][j].setX(0);[m
[32m+[m[32m      grid[i][j].setY(0);[m
[32m+[m[32m      /*[m
[32m+[m[32m      std::cout << "X: " << grid[i][j].getX() << std::endl;[m
[32m+[m[32m      std::cout << "Y: " << grid[i][j].getY() << std::endl;[m
[32m+[m[32m      */[m
[32m+[m[32m    }[m
   }[m
 }[m
 [m
[1mdiff --git a/main.cpp b/main.cpp[m
[1mindex 00eb0a6..901c335 100644[m
[1m--- a/main.cpp[m
[1m+++ b/main.cpp[m
[36m@@ -35,8 +35,9 @@[m [mint main (int argc, char* argv[]) {[m
     grid[i] = new Grid[grid_sz];[m
   }[m
   Particle par[part_no];[m
[31m-  init_grid(grid_sz, grid);[m
[32m+[m[32m  //init_grid(grid_sz, grid);[m
   init_particles(seed,grid_sz,part_no,par, grid);[m
[32m+[m[32m  update_center(grid_sz, grid, par);[m
 [m
   //isto esta a dar erro a passar este grid, still couldnt find out why[m
 [m
[1mdiff --git a/make.sh b/make.sh[m
[1mnew file mode 100755[m
[1mindex 0000000..be073d4[m
[1m--- /dev/null[m
[1m+++ b/make.sh[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32mg++ --std=c++11 main.cpp particle.cpp grid.cpp init_particles.cpp -o simpar[m
[1mdiff --git a/particle.h b/particle.h[m
[1mindex c437b4e..5cfb983 100644[m
[1m--- a/particle.h[m
[1m+++ b/particle.h[m
[36m@@ -27,3 +27,4 @@[m [mclass Particle {[m
 };[m
 [m
 void init_particles(long seed, long ncside, long long n_part, Particle *par, Grid **grid);[m
[32m+[m[32mvoid update_center (int size,Grid **grid, Particle *par);[m
[1mdiff --git a/simpar b/simpar[m
[1mindex 836bec8..7c3258c 100755[m
Binary files a/simpar and b/simpar differ
